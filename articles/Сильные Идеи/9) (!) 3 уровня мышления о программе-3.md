## Три уровня рассуждений о программной системе - 3

Впечатление, что программирование с каждым днём всё больше превращается в запоминание кусков кода со stackoverflow и стандартных функций и последующее их комбинирование в надежде "угадать" правильное решение. Сторонники запоминания длиннющих перечней шаблонов проектирования и методов рефакторинга при этом даже не понимают разницу между метриками method-method coupling, method parameter coupling и method invocation coupling, с хоторых начинается запутывание и рост сложности в любом проекте.

---

Забудьте об этой тотально ложной парадигме, которую вам навязывает мэйнстрим. Изучая фигню, вы и специалистом станете по фигне, и работу будете искать соответствующую. Пока ещё можно много выиграть, просто изучив общие принципы computer science, которые универсально применимы ко многим ситуациям в разработке.

В этом посте посмотрим повнимательнее на важный принцип проектирования, с которым вы познакомились в предыдущих ч астях:  **вы всегда должны писать код так, чтобы дизайн был достаточно явно заметен и наглядно понятен** . Именно это делает ваш код более читаемым, слабо связанным и невосприимчивым к ошибкам. Но это трудно понять, потому что программисты очень редко видят первоклассный программный дизайн.


### Три уровня рассуждений о программной системе - 3

Сильные принципы проектирования хороши ещё и тем, что они могут использоваться как "машины" для формирования примеров, которые его нарушают. Такие примеры, такой код всегда выглядит разумным для неподготовленного разработчика, но вызывает смешные и одновременно ужасные ошибки.

Типичный пример. Олег -- разработчик в стартапе макро-блогов Figambex.ru. Он работает там всего несколько месяцев, но его уже назначили на очень важный проект: он создаёт страницу статистики сайта! Теперь каждый может увидеть, насколько активны пользователи Figambex-a. Олегу в частности надо выводить количество пользователей, количество написанных пользователями страниц и количество написанных пользователями слов.


### Три уровня рассуждений о программной системе - 3

Олег приступает к кодированию. Конечно, надо сразу закладываться на перспективу, на миллиарды пользователей, поэтому в сервисе уже активно применяется кэширование. Олегу предоставлен доступ к внутреннему API -- набору функций, которые обрабатывают соответствующие стуктуры данных, и он с их помощью сделал прикладную логику, которая выводит либо вычисленное, либо кэшированное значение.

*(условный псевдокод :)*

```
function display_stats():
  if last_cached_time <= last_midnight():
    num_users = count_users()
    last_cached_time = time.now()
    echo("Total Users: " + num_users)
  else:
    echo("Total Users: " + num_users)

  if last_cached_time <= last_midnight():
    num_topics = count_topics()
    last_cached_time = time.now()
    echo("Topics written: " + num_topics)
  else:
    echo("Topics written: " + num_topics)

  if last_cached_time <= last_midnight():
    num_words = count_words()
    last_cached_time = time.now()
    echo("Words written: " + num_words)
  else:
    echo("Words written: " + num_words)
```

Вуаля! По мере того, как будут накапливаться различные показатели статистики, будет легко добавлять подобные их обработчики, просто повторяя данный шаблон.

Олег отправляет свой код сеньору Пете на code review.

Отмечу один момент по поводу Пети: он -- это не я. Видите ли, я бы, пожалуй, сразу рассказал Олегу обо всех этих потенциально плохих вещах, которые случатся из-за этого кода, прочитал бы ему небольшую лекцию и дал ссылку на материалы в СильныхИдеях.
Петя, однако, просто отхлёбывает Адреналин и говорит: "Тут есть не очень приятный момент, что ты повторно используешь last_cached_time в проверке, которая копипастится. Но в целом, выглядит хорошо". И даёт добро на комит в мастер, так как у него полно своих забот.


### Три уровня рассуждений о программной системе - 3

Прошло полгода. Figambex.ru растет быстрее, чем российские цены. Сайт Figambex требует более частых обновлений страницы статистики, нежели раз в сутки. Тимлид Денис решает удвоить частоту обновления, назначив тикет на Петю.

Петя сперва правит все три строчки одинаковым образом, и сообщает Олегу.

```
function display_stats():
   if last_cached_time <= last_midnight() or last_cached_time <= last_noon():
    num_users = count_users()
    last_cached_time = time.now()
    echo("Total Users: " + num_users)
  else:
    echo("Total Users: " + num_users)

if last_cached_time <= last_midnight() or last_cached_time <= last_noon():
    num_topics = count_topics()
    last_cached_time = time.now()
    echo("Topics written: " + num_topics)
  else:
    echo("Topics written: " + num_topics)

if last_cached_time <= last_midnight() or last_cached_time <= last_noon():
    num_words = count_words()
    last_cached_time = time.now()
    echo("Words written: " + num_words)
  else:
    echo("Words written: " + num_words)
```

На что Олег справедливо отмечает, что Петя сам ругался на копипасту, и что ранее они ведь уже решили, что вся статистика должна обновляться одновременно. "Упс" -- говорит Петя, и вместе они объединяют условия в одно.

```
function display_stats():
  if last_cached_time <= last_midnight() or last_cached_time <= last_noon():
    num_users = count_users()
    num_topics = count_topics()
    num_words = count_words()
    last_cached_time = time.now()

  echo("Total Users: " + num_users)
  echo("Topics written: " + num_topics)
  echo("Words written: " + num_words)
```


### Три уровня рассуждений о программной системе - 3

Проходит ещё один год. Figambex.ru взлетел как биткоин. На странице очень выразительной статистики теперь десятки пунктов. Пора начинать упрощать! Опросы показывают, что никто на самом деле не интересуется количеством слов, поэтому ребята удаляют его:

```
function display_stats():
  if last_cached_time <= last_midnight() or last_cached_time <= last_noon():
    num_users = count_users()
    num_topics = count_topics()
    num_words = count_words()
    last_cached_time = time.now()

  echo("Total Users: " + num_users)
  echo("Topics written: " + num_topics)
```

*Стандартная оговорка: При чтении любых рекомендаций по разработке (и у меня, и в любых других статьях и книгах) всегда предполагайте, что все приводимые примеры как минимум в 10 раз длиннее* .

Джекпот! Пользователи на Figambex.ru постят 10,000 сообщений в сутки. Но однажды системный инженер замечает, что дважды в день, в полдень и в полночь, на сервере случается большое замедление. Потратив немало часов на выискивание баттлнека, он обнаруживает, что замедление как-то связано с тем, что во время обновления кэша страница статистики требует аж трёх минут для загрузки! С ужасом он обнаруживает нагрузочный вызов countWords(), который всё ещё живой, хотя его результаты давно не используются...


### Три уровня рассуждений о программной системе - 3

Это был просто случай "ошибки случаются". Это ощутимая цена, которую пришлось заплатить за плохо спроектированный код. Всё, начиная с самых первых неточностей, и заканчивая замедлением работы сайта, можно было предотвратить, структурировав код лучше. А лучший способ структурирования -- применение принципа дизайна, явно видимого в коде.

Абстрагируйтесь как можно раньше. Конечно, чрезмерный инжиниринг -- это плохо. Но если вы не уверены, будет ли применение данного подхода к вашему коду оверинжинирингом, считайте, что это не оверинжиниринг.

---

В первой версии кода три условных "элемента" - "вычисление", "кэширование" и "отображение", по каждой из трёх статистик, были независимыми элементами. В коде это были отдельные инструкции, но на практике их реальная логика скорее всего была бы достаточно объёмной, и в системе они представлялись бы отдельными компонентами. Таким образом, если количество отображаемых статистик равняется N, то таких "элементов" кода требовалось бы 3*N. Слияние условий объединило проверки поведения кэширования в одно, сводя общее количество "элементов" к 2*N+1, но тем не менее, в коде всё ещё выполнялось холостое вычисление одной из статистик без её отображения.

Этот пример экстремально простой, однако его схема совершенно реальна. Например, ребята из Массачусетского технологического института рассказывали, что когда один из них консультировал eBay, то был шокирован схемой, когда очень активно используемое в коде обращение к некоторой вроде бы простой функции внутри представляло собой обращение к базе данных.


### Три уровня рассуждений о программной системе - 3

К чему надо стремиться? Концептуально, набор статистик и логика их кэширования должны быть представлены только N+1 "элементом": каждая статистика в целом может быть включена или выключена "целиком", и поведение кэширования также может быть изменено автономно, без влияния на остальной код. Достаточно опытный программист тут скорее всего сразу заметит, что логика вычисления и вывод информации в UI, даже если они выполняются на одной стороне (например, только на сервере как server side rendering), объединять в одно "целое" -- ну, как минимум даже потенциально возможно далеко не всегда, так как например используемый фреймворк в модели MVC такое не позволит. Да, тут имеются определённые сложности, речь вот о чём: достижение такой автономности компонентов, распутывание такой сцепленности подразумевают нелокальные изменения проекта, и не будут очевидными и простыми, если вы будете думать только на 2-м уровне -- о том, что делает код, и не более. Проблему правильного развязывания логики и UI рассмотрим, в частности, в цикле курсов "как понять в программировании всё".

Хорошие программисты интуитивно понимают такие моменты, стараясь например избегать даже вложенных условий, закономерно подозревая их в потенциальной опасности (очень рекомендую в этой связи мини-курс "Быстрая прокачка в ООП"). Однако они продолжают думать в терминах кода, и по мере роста его объёма и отсутствия логической целостности, которую можно "пощупать" (удерживать взаимосвязи в голове), постоянно допускают вышеописанные ошибки.


### Три уровня рассуждений о программной системе - 3

Один из популярных подходов к проектированию -- использование рисовалок диаграмм, но такие неформальные попытки описания архитектуры довольно справедливо критикуются, потому что на практике такие схемы с квадратиками живут своей оторванной от реального кода жизнью, и делаются для галочки. Программисты -- текстоориентированные существа, не слишком симпатизирующие картинкам. Однако всё же надо отметить, что в случае мышления именно на третьем уровне построители схем, иерархий диаграмм, оказываются весьма полезными.

Существуют кстати и полноценные построители формальных моделей с последующей автоматической кодогенерацией (и даже с поддержкой двусторонней конвертации код-модель), но пока они довольно сильно ограничены по своим возможностям, потому что требуют высокой квалификации (это буквально научная работа), а в реальных проектах приходится активно использовать множество дополнительных библиотек, которые формализовать нереально, да и фреймворки накладывают большие ограничения на структуру проекта.

А вот диаграммы дают хотя бы примерное представление о понятиях, используемых при проектировании программы, показывая, как некоторая "статистика на странице статистики" многократно инстанцируется в коде, и как её конкретные экземпляры, "конкретные статистики", встраивается в код. Например, мы сразу можем увидеть, как проверки кэширования выполняются в коде несколько раз, что сделало возможным ошибку в первой версии Олега.


### Три уровня рассуждений о программной системе - 3

В идеале, код должен быть неотличим от логического дизайна, в котором каждая статистика имеет свою собственную политику кэширования (настраиваемую, например, конфигурационными файлами). И наконец, каждая статистика должна выражаться своим полностью независимым кодом, своим "тумблером" в системе (который, как уже говорилось, надо уметь корректно "размазывать" по разным аспектам -- бизнес-логике, UI, ...). Отсюда и замедление, которое затормозило Figambex.ru.

Это можно исправить, и код сделать красивым, если отводить буквально по одной (двум, трём...) строке кода на каждую простую концепцию низкого уровня. Это будет истинная версия принципа "Не повторяйся" (DRY).

---

Когда веломеханик настраивает велосипед, он проверяет трансмиссию, систему торможения и тому подобные высокоуровневые концепции. Но вы скорее всего не сможете попросить в магазине велозапчастей трансмиссию: вам надо выбрать по отдельности каретку, кассету, цепь, хорошо подходящие и друг другу, и вашему велосипеду. Остальные понятия существуют только в голове механика.

Мы программисты, и у нас есть инструменты, которые воплощают наши мысли в инструкции для процессора. И в некоторой степени, мы действительно можем встраивать эти абстрактные концепции прямо в наш код.


### Три уровня рассуждений о программной системе - 3

На уровне дизайна вполне естественной будет концепция дашборда: вычисления + текстовое поле (или даже физический объект вывода в UI например). Добавим эту концепцию непосредственно в код:

```
interface stats_computation:
  object compute(): ...

class dashboard_stat:
  private stats_computation computation;
  private string text_label;
  // конструктор, геттеры ...

class dashboard:
  private list<dashboard_stat> stats;
  private time last_computed_time;
  private map<dashboard_stat, object> values;
  public map<dashboard_stat, object> get_values(): ...
  // ...

function display_dashboard():
  print(dash.get_values())

//
 
dash = new dashboard(
           list( new dashboard_stat(count_users, "Total Users")
               , new dashboard_stat(count_articles, "Articles written")
               , new dashboard_stat(count_words, "Words written"))
```

И вот за счёт того, что такие высокоуровневые концепции превратились в код, оригинальная версия Олега теперь может быть записана декларативно. Этот код получился таким простым, что он фактически не может ошибаться. Мы добавляем или удаляем целиком каждую статистику как целостное понятие (легко настраиваемое на нужную схему вычислений).


### Три уровня рассуждений о программной системе - 3

Однако на практике невозможно превратить свою программу в чистое выражение дизайна (ну, если вы не Роберт Харпер). Вам всегда придётся идти на компромисс в отношении того, как далеко поолучится тут зайти. Вот ещё некоторые другие варианты:

- Можно полностью избавиться от гибко настраиваемого класса dashboard_stat с интерфейсом stats_computation, и оставить абстрактный класс dashboard_data, для которого создавать наследники, где соответствующая логика вычислений и вывода текста закодирована жёстко. Однако всё равно мы сохраняем подход, что каждая статистика должна вычисляться обрабатываться по принципу "целиком или ничего".
- Можно выделить проверку на необходимость пересчета в метод should_update в классе dashboard. Теперь решения по поводу истекшего времени о тайминге кэша будут пересматриваться в отдельном фрагменте кода. В идеале, политика кэширования может быть параметризована конфигурационным файлом.
- Можно обернуть каждую текстовую строку в вызов функции интернационализации. Лучше сделать её тонкой прослойкой, которая исходно никаких дополнительных манипуляций не делает, однако выбор языка сразу становится явным во всём вашем коде.


### Три уровня рассуждений о программной системе - 3

Думаю, что многие программисты уже на самом первом примере обычно почувствовали, что что-то в нём не так. Многие сразу скажут, что лучше объединить условные проверки, и выполнить другие мелкие улучшения. Но те, кто "понимают", что тут полезно выполнить рефакторинг, понимают это только каким-то микро-инсайтом, смутным ощущением, и не могут ясно и чётко сформулировать, а как именно и почему именно так они это придумали.

Когда вы напряжённо думаете, как же получить правильный код из дизайна (код должен быть неотличим от логического дизайна), это значит, что что-то уже пошло не так.

Найти хорошую структуру кода должно быть легко, как только мы увидели ясную структуру дизайна.

Так что всегда думайте нестандартно, поднимайтесь над кодом. Поспрашивайте себя о концепциях вашей программы, о типах и значениях, которые их определяют и реализуют. Это то, что превращает вас из механика, подкручивающего винты, в инженера или художника, создающего что-то элегантное и красивое, чем вполне можно гордиться.
