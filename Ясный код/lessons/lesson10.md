## Типы данных

### 1. Общие рекомендации

Выполняйте преобразования типов понятно -- а лучше вообще никогда не приводите значения одних типов к другим.

Избегайте сравнений значений разных типов.

Обращайте внимание на предупреждения вашего компилятора (включите все предупреждения по максимуму).

Каждый раз, когда вы пользуетесь символом деления (/ в большинстве языков), думайте о том, может ли в знаменателе оказаться 0. Если такая возможность существует, напишите код, предупреждающий появление ошибки деления на 0.

### 2. Целые числа

Проверяйте целочисленность операций деления (используйте подходящие операции деления).

Проверяйте возможное переполнение целых чисел.

Проверяйте на переполнение промежуточные результаты вычислений внутри выражений.

### 3. Вещественные числа

Избегайте сложения и вычитания слишком разных по величине чисел.

Избегайте сравнений на равенство.

Предупреждайте и учитывайте ошибки округления.

Измените тип вещественной переменной на тип с большей точностью.

Если вы используете числа с одинарной точностью, замените их числами с двойной точностью и т. д.

Измените в коде места, где используются значения с плавающей запятой, на целые значения, если это возможно.

Проверяйте поддержку специальных типов данных в языке и дополнительных библиотеках.

### 4. Строки и символы

Избегайте магических символов и строк -- используйте константы.

Узнайте, как ваш язык и система поддерживают Unicode, и перейдите на этот формат.

Разработайте стратегию интернационализации/локализации текстовых сообщений в вашем коде (делайте это в самый ранний период создания программы).

Выберите целостную стратегию преобразования строковых типов, если они используются в вашей программе в разных кодировках.

### 5. Логические переменные

Активнее используйте логические переменные для повышения читабельности программы.

Пример правильного использования булевой переменной:

```
boolean finished = elementIndex < 0 || elementIndex > MAX_ELEMENTS;
boolean repeatedEntry = ( elementIndex == lastElementIndex );
if ( finished || repeatedEntry ) { ... }

finished = elementIndex < 0 or MAX_ELEMENTS < elementIndex
repeatedEntry =  elementIndex == lastElementIndex 
if finished or repeatedEntry: ...
```

К этому примеру: используйте логические переменные для упрощения сложных условий. Если через некоторое время потребуется модифицировать это условие, бывает сложно разобраться, что же оно проверяет. Логические переменные помогут упростить проверку.
