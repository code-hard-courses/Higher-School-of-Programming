## Абстрактные типы данных (АТД)

Мы изучали абстрактный тип данных в декларативной модели -- это  **набор значений вместе с набором операций над этими значениями** . Теперь мы добавим в АТД понятие состояния.

### 8. 8 способов организации АТД

АТД с одинаковой функциональностью "внутри" могут быть организованы (реализованы) по-разному. Например, ранее мы изучали, как сделать АТД защищённым. Теперь введём ещё две оси -- **состояние и бандлинг** (bundling; упаковка, связывание, комплектация), каждая из которых предлагает два варианта. Эти три оси ортогональны, и в общей сложности получается восемь способов для организации АТД. Одни из них используются редко, другие распространены, но у каждого свои преимущества и недостатки.

### 1) Открытость и защищённость

**Открытый АТД -- это такой АТД, внутреннее представление которого полностью видимо во всей программе** . Реализация может быть распределена по всему коду, и различные её части могут расширять реализацию независимо друг от друга. Это полезно для небольших проектов, когда выразительность значительно важнее, нежели безопасность.

**Защищенный (безопасный) АТД -- это такой АТД, реализация которого сосредоточена в одной части программы, и недоступна остальным частям** . Обычно так желательно или требуется в больших проектах, потому что такой подход позволяет реализовать и тестировать АТД независимо. Возможно, вы удивитесь, но безопасный ADT может быть полностью определён в декларативной модели, используя принципы программирования высшего порядка. Никаких дополнительных концепций (например, имён и видимости) не требуется.

АТД может быть **частично безопасным** -- например, права на просмотр его внутренней реализации могут быть выданы контролируемым образом, как мы реализовывали функции Wrap и Unwrap для реализации стеков.

### 2) Состояние

Stateless-АТД (или декларативный АТД) создаётся в декларативной модели.  **Декларативные экземпляры АТД модифицировать не разрешается: надо создавать новые сущности** . Поэтому, когда процедуре передаётся экземпляр АТД, всегда можно быть уверенным, что это значение уникальное -- после своего создания экземпляр АТД никогда не изменяется. С другой стороны, такой подход приводит к увеличению количества экземпляров в программе, которыми со временем становится трудно управлять. Код также получается менее модульным, поскольку экземпляры должны явно передаваться по конвейеру даже через те части, которые могут и не нуждаться в экземпляре АТД.

**Stateful-АТД внутри использует явное состояние. При таком подходе экземпляры АТД могут изменяться с течением времени** . При этом нельзя быть уверенным, какое именно значение инкапсулировано внутри экземпляра, не зная истории всех вызовов процедур с момента его создания.

В отличие от декларативных АТД, в данном случае существует только один физический экземпляр. Более того, этот единственный экземпляр часто даже не нужно передавать в функции в качестве параметра; доступ к нему можно получить с помощью лексического замыкания. Такой подход делает программу более лаконичной. Программа также становится потенциально более модульной, поскольку части, которым не нужен экземпляр, можно не упоминать.

### 3) Бандлинг

Наряду с безопасностью и состоянием, третий выбор, который необходимо сделать, заключается в том, будут ли данные храниться отдельно от операций (распаковка, unbundled), или же будут храниться вместе (bundled). Конечно, распакованный АТД всегда можно запаковать тривиальным способом, поместив данные и операции в одно целое. Но запакованный АТД практически не может быть распакован; семантика гарантирует, что он всегда остается запакованным. Конечно, всегда можно выполнить технический рефакторинг проекта, тут речь о формальном подходе к распаковке.

**Распакованный АТД -- это АТД, для которого можно отделить данные от операций** . Замечательный факт, что  **распакованный АТД может быть безопасным** . Для этого каждый экземпляр создается вместе с "ключом". Ключ -- это разрешение на доступ к внутренним данным экземпляра (и обновление их, если экземпляр имеет состояние). Все операции АТД знают ключ, но остальная часть программы не имеет к ключу доступа. Обычно ключ - это имя (неизменяемая константа).

Распакованный АТД может быть более эффективным, чем запакованный. Например, в файле можно хранить наборы значений, каждое из которых будет соответствовать своему экземпляру АТД. Запакованный АТД подразумевает, что требуется хранить вместе и код и операции таким образом, что они не могут быть разделены программистом. Пример -- ООП, когда в памяти каждый объект хранится как набор данных и операций их обработки (методов). На практике, конечно, один и тот же код методов целиком в каждом объекте физически обычно не хранится, достаточно иметь лишь ссылку на код, и тем не менее сам подход создаёт ощутимые сложности.


### Способы организации АТД с состоянием (задания)

======= 18. Защищённый АТД -- это АТД ...

[1 ] реализация которого сосредоточена в одной части программы и недоступна остальным частям

[ ] в котором все поля инкапсулированы

[ ] реализация которого сосредоточена в одной части программы, но доступна остальным частям

======= 19. Stateful-АТД -- это АТД ...

[ ] в котором все поля доступны для модификации

[ ] в котором имеются собственные инкапсулированные поля

[1 ] экземпляр которого может изменяться с течением времен

======= 20. Распакованный АТД -- это АТД ...

[ ] значения которого можно хранить в файле

[ ] в котором все поля публичны

[ 1] для которого можно отделить данные от операций
