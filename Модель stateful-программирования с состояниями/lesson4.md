## Декларативная модель с явным состоянием

Явное состояние -- это пара из двух сущностей языка программирования. Первая сущность -- это **идентичность (identity)** состояния, способ его именования в программе, а второе -- **текущее содержание состояния** (значение, с которым связано имя, идентичность состояния). И существует операция, которая позволяет через идентичность состояния получить текущее содержимое состояния.

### 7. Ячейка

Мы добавляем новый базовый тип в вычислительную модель -- явное состояние, и называем его  **ячейка** .

Ячейка состоит из неизменяемого имени и связанной с ним ссылки на объект в хранилище однократных присваиваний. Так как имя ячейки менять не допускается,  **все ячейки получаются чистыми АТД** . Множество всех ячеек располагается в мутабельном хранилище.


Итоговая вычислительная модель состоит из иммутабельного хранилища однократных присваиваний, которое хранит dataflow-переменные (которые могут быть связаны только с одним значением), и из мутабельного хранилища, которое хранит пары из имён и ссылок. В этой вычислительной модели существует простой язык программирования, который расширяет декларативную модель всего двумя операциями: NewCell и Exchange.

NewCell имеет два параметра C и X и создаёт новую ячейку с именем C и содержимым X.

Exchange имеет три параметра C, X и Y, связывает X с прежним (текущим) содержимым ячейки C, и задаёт этой ячейке новое содержимое Y.

Для большей выразительности в терминах этих операций в модель добавляются ещё две инструкции.

Операция @ организует доступ к содержимому ячейки C:

```
X = @C
```

Операция := присваивает ячейке C новое значение Y, и возвращает старое значение ячейки X:

```
C := Y
```

Удивительно, но **добавления ячейки с двумя операциями (фактически, классические запись значения и считывание значения) достаточно, чтобы построить все замечательные концепции, которые может предоставить понятие состояния!** **Все сложные концепции объектов, классов и других абстрактных типов данных могут быть построены с помощью декларативной модели, дополненной ячейками.**

Это семантика, но и языки обычно имеют синтаксическую поддержку этих концепций, чтобы они стали простыми в использовании, а реализация обеспечивает их эффективность.


## Связь с декларативным программированием

Вообще говоря, stateful-программа не может считаться декларативной, так как её прогон несколько раз с одними и теми же входами может давать разные выходы в зависимости от её внутреннего состояния. Можно, однако, писать stateful-программы так, что они будут вести себя как если они декларативные -- т.е. писать их так, чтобы они удовлетворяли определению декларативной операции. Это сам по себе хороший принцип проектирования:  **писать stateful-компоненты так, чтобы они вели себя декларативно** .

Можно взять любую функцию из предыдущего курса, например Filter(), и переписать её в императивном виде, без рекурсии: просто одним циклом перебрать все элементы списка, и если очередной элемент отвечает требованиям функции-предиката, добавляем его в список-результат. Этот список-результат -- локальная переменная внутри Filter, явное состояние, однако с точки зрения пользователя функция Filter осталась декларативной: она не меняет значения аргументов и не создаёт никаких других побочных эффектов.  **Мы просто сменили декларативную реализацию декларативной функции Filter на императивную, оставив её "интерфейс" (сигнатуру) неизменным** .

Ещё одна полезная вещь, связанная с состоянием и декларативной моделью -- это мемоизация, когда функция запоминает результаты предыдущих вызовов (если они например требовали больших объёмов вычислений), и при повторных вызовах с теми же параметрами выдаёт результат молниеносно. Такая функция где-то внутри работает с состояниями (замыканием), однако формально остаётся декларативной.


### Декларативная модель с явным состоянием (задания)

======= 12. Ячейка -- это ...

[ ] переменная

[ ] элемент в иммутабельном хранилище

[ 1] имя и связанная с ним ссылка на объект

======= 13. Сколько операций для ячейки достаточно, чтобы полноценно реализовать концепцию состояния?

[ ] три

[1 ] две

[ ] четыре

======= 14. Как писать stateful-компоненты так, чтобы они вели себя декларативно?

[ ] сохранять декларативный интерфейс

[1 ] сохранять декларативную реализацию

[ ] сохранять декларативные интерфейс и реализацию
