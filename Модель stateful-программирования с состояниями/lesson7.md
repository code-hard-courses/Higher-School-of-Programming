## Практические способы организации АТД

На практике из восьми комбинаций способа организации АТД обычно используются следующие (по мере усложнения):

- Открытый, декларативный, распакованный. Этот подход реализован например в языках Scheme и Prolog.
- Защищённый, декларативный, распакованный. Добавляем "обёртки" для реализации безопасного декларативного стиля.
- Защищённый, декларативный, запакованный. Получаем объектно-ориентированное расширение декларативного стиля.
- Защищённый, stateful, запакованный. Классический ООП, как в Smalltalk или Java.
- Защищённый, stateful, распакованный. Распакованный вариант ООП.

Первые два пункта мы рассматривали на предыдущем курсе:
-- NewStack() – создать новый стек;
-- Push(Stack s, T elem) – втолкнуть элемент elem в стек s;
-- Pop(Stack s) – вытолкнуть элемент из стека s;
-- T Peek(Stack s) – получить верхний элемент стека s, не меняя сам стек;
-- IsEmpty(Stack s) – булева проверка, пустой ли стек s.

Первые три функции возвращают в качестве своего значения новый стек, так как все функции чистые и не меняют значений своих аргументов.

### Защищённая декларативная распакованная версия с обёртками

-- NewStack() возвращает Wrap( [ ] ).

-- Peek(Stack s) и IsEmpty(Stack s) делают предварительно внутри Unwrap(s).

-- Push(Stack s, T elem) и Pop(Stack s) после Unwrap(s) модифицируют результат и затем выполняют Wrap() для нового списка, который и возвращает.

### Защищённая декларативная запакованная версия

Идея -- спрятать стек внутри операций с помощью лексического замыкания, так что он не может быть от них отделён. Синтаксис становится похожим на ООП:

```
S1 = NewStack()
S1.IsEmpty()
S2 = S1.Push(23)
S3 = S2.Pop(X)
S4 = S3.Pop(Y).Push(256).Push(-1)
```

Мы придерживаемся декларативной модели, каждый "метод" по-прежнему возвращает новый стек, не меняя текущий. Так как эта версия запакована, обёртки Wrap/Unwrap вызывать не нужно: мы получаем в качестве результата не "физический" стек, а некий "объект", заглянуть внутрь которого невозможно. Для обеспечения безопасности такого АТД не требуется явного состояния, достаточно только программирование высшего порядка.

Поскольку эта версия является одновременно запакованной и безопасной, мы можем рассматривать ее как  **декларативную форму объектно-ориентированного программирования** . По сути, мы получили декларативный объект.

### Защищённые stateful-версии

**Защищённый, stateful, запакованный стек** реализуется классическим подходом ООП + АТД. Есть объект, содержащий внутреннее поле (сам стек в некотором внутреннем представлении, например связный список), которое инкапсулировано, и есть методы доступа к нему и его модификации.

**Защищённый, stateful, распакованный стек** на практике применяется редко в ООП и ФП, хотя и незаслуженно. Он не требует программирования высшего порядка.  **Каждая операция требует один параметр (стек) и не создаёт новый объект, модифицируя аргумент** . Только операция NewStack требует вызова Wrap, все остальные операции используют лишь Unwrap для доступа к внутреннему представлению стека.

```
S1 = NewStack()
IsEmpty(S1)
Push(S1, 23)
X = Pop(S1)
```


### Практические способы организации АТД (задания)

======= 21. ООП -- это ...

[ ] защищённый, stateful, запакованный АТД

[ ] защищённый, декларативный, запакованный АТД

[ ] защищённый, stateful, распакованный АТД

======= 22. Объектно-ориентированное расширение декларативного стиля -- это ...

[ ] защищённый, stateful, запакованный АТД

[ ] защищённый, декларативный, запакованный АТД

[ ] защищённый, stateful, распакованный АТД

======= 23. Какой защищённый stateful АТД не требует создания нового объекта?

[ ] запакованный

[ ] распакованный

[ ] никакой
