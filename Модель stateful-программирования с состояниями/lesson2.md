## 2. Состояние (State)

**Состояние -- это последовательность значений, растянутая во времени** , которая содержит промежуточные результаты желаемого вычисления.

### Скрытое (декларативное) состояние

Сама последовательность значений может существовать лишь в голове программиста, и никакой явной её поддержки со стороны вычислительной модели не существует. Например, рекурсивное вычисление факториала 5 подразумевает последовательное вычисление факториала 2, факториала 3, факториала 4 и факториала 5 -- это и есть состояние. Однако "физически", на уровне кода, такой последовательности не существует.

### Явное состояние

Если требуется подсчитать количество вызовов функции вычисления факториала, придётся вводить состояние, которое существует внутри такой функции и в идеале скрыто от внешних функций, её вызывающих.

**Явное состояние в функции -- это состояние, которое существует на протяжении более чем одного вызова этой функции без явного присутствия в её аргументах.**

Явное состояние реализуется с помощью своего рода контейнера, который мы называем  **ячейка** , и существует уже не только в сознании программиста.

**Ячейка характеризуется
a) своим именем,
b) неограниченным сроком службы и
c) содержанием, которое может быть изменено.**

**Декларативная модель, расширенная ячейками, называется stateful-модель** .


## 3. Как продуктивно разрабатывать системы в stateful-модели и в императивном программировании?

Какое отношение концепция состояния имеет к построению сложных программных систем?

Самый успешный и продуктивный способ построения системы для людей, способности которых к логическому мышлению существенно ограничены -- это  **принцип абстракций** . Любая система состоит из двух частей:  **спецификации и реализация** .
Спецификация -- это формальный контракт, который определяет, как мир взаимодействует с системой, если смотреть на это взаимодействие со стороны.
Реализация -- это то, как система сконструирована, если смотреть на это изнутри неё.

Замечательное свойство спецификации в том, что  **спецификация, как правило, намного проще для понимания, нежели реализация** . Не нужно знать, как устроены часы, чтобы понимать, какое время они показывают.

Это означает, что можно эффективно строить систему в виде серии слоев абстракций. В каждом слое формируется реализация, которая использует спецификацию более низкого уровня, и предоставляет свою спецификацию слою выше. Не обязательно пытаться понимать всю систему сразу.

**Растущие системы**

Принцип абстракции не очень хорошо поддерживается декларативным и функциональным программированием, потому что мы не можем вкладывать новые знания в компоненты или функции, инкапсулируя эти знания внутри.


## 4. Принцип абстракции

Какой должна быть система, чтобы обеспечить наилучшую поддержку принципа абстракции?

У неё должны присутствовать три ключевые характеристики:
--  **Инкапсуляция** : возможность скрывать внутренние части системы;
--  **Композиционность** : возможность комбинировать части системы, чтобы получать новые части;
--  **Instantiation/invocation** : возможность создания множества экземпляров на основе единого их определения. После своего создания экземпляры самоподключаются к своему окружению, в котором будут существовать.

Даже поверхностным взглядом на эти характеристики программист, знакомый с ООП, выделит знакомые концепции: инкапсуляция уже присутствует; классы можно комбинировать путём наследования или композиции; на основе класса как типа данных можно создавать экземпляры, объекты, которые сразу же доступны для работы.

Но мы применяем научный подход и используем более универсальные, формальные и фундаментальные принципы программирования. Например, замыкания обеспечивают инкапсуляцию, и программирование высших порядков обеспечивает инстанцирование (создание экземпляров).

**Важная особенность такого набора характеристик, что он не требует напрямую использования концепции состояния** .

Инкапсуляция, формально говоря, вообще ортогональна состоянию, и её вполне можно применять в декларативном программировании, а состояния могут обходиться без инкапсуляции (например, через создание глобальных переменных).


Однако простое добавление состояния к декларативному программированию резко усложняет возможность рассуждения о программе, серьёзно затрудняет её понимание. Это прежде всего  **побочные эффекты** , когда функция может менять состояния, которые видимы во всей остальной программе. Поэтому  **явное состояние правильно всегда применять в тесной связке с инкапсуляцией** . Тогда появляется возможность проектировать stateful-системы корректно, для чего вводится  **понятие инварианта, который всегда правилен, если смотреть на него извне, "снаружи"** . Таким образом мы снова можем рассуждать о каждой подсистеме достаточно формально, считая, что её поведение не зависит от окружающей среды, что частично приближает нас к комфортному в этом плане декларативному программированию. Однако даже использование инвариантов не делает программировании с помощью состояний таким простым, как декларативное.

**Инвариант сам по себе просто определяет, что некоторый компонент не ведет себя некорректно** , но не гарантирует, что он помогает в продвижении к итоговой цели (решению).  **Хорошее правило для сложных систем -- создавать как можно больше компонентов в декларативной парадигме** . Состояние не должно быть "размазано" по многим компонентам, его надо концентрировать буквально в единичных тщательно отобранных компонентах.


### Состояние и абстракции (задания)

======= 5. Состояние –- это...

[ ] Ячейка-контейнер

[ 1] Последовательность значений во времени

[ ] Типизированная переменная

======= 6. Принцип абстракций подразумевает, что система состоит из ...

[ 1] спецификации и реализации

[ ] интерфейса и реализации

[ ] типа и имплементации

======= 7. Выберите одну лишнюю ключевую характеристику правильной системы

[ ] инкапсуляция

[ ] композиционность

[ 1] полиморфизм

[ ] instantiation/invocation

======= 8. Выберите одно неверное утверждение

[ ] инварианты обеспечивают корректность всех подсистем проекта

[+] состояние надо всегда инкапсулировать

[ ] состояние может быть "размазано" по многим компонентам, если оно инкапсулировавно

[+] состояние вносит побочные эффекты

[+] как можно больше подсистем надо создавать в декларативной модели
