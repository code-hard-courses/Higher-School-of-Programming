### 2) Взаимодействие между компонентами

Когда компоненты соединены вместе, они должны начать взаимодействовать друг с другом. Далее приведены шесть наиболее популярных протоколов для такого взаимодействия, в порядке возрастания независимости компонентов.

**1. Процедура/функция.**

Логика программы последовательна, и один компонент вызывает другой как функцию. Вызывающая сторона может быть не единственным инициатором такого вызова; допустимы вложенные вызовы, когда фокус управления переходит от одного компонента к другому.  **Но всегда существует только один глобальный фокус управления** , который в каждый момент времени напрямую связывает два конкретных компонента.

**2. Корутина.**

Два компонента выполняются независимо, но последовательно передавая управление друг другу. Выполнилась часть кода одного компонента, затем управление передаётся другому компоненту, который выполняет часть своего кода, и передаёт управление обратно первому компоненту, который продолжает работу с последней промежуточной точки (с сохранением своих локальных состояний), и т. д.
Тут возникает уже  **несколько фокусов контроля, по одному на каждую корутину** . Этот протокол более свободный, нежели предыдущий, но компоненты всё ещё зависимы, поскольку выполняются попеременно и связаны с друг с другом.

**3. Параллельность и синхронизм.**

Третья схема -- когда каждый компонент развивается независимо от других, и может инициировать и завершать связь с другим компонентом в соответствии с некоторым протоколом, который согласован для обоих компонентов. Компоненты работают параллельно.  **Тут существует несколько фокусов контроля, которые называются "нити" (threads)** , мы их проходили на первом курсе по парадигмам. Каждый компонент однако обращается к другим компонентам  **синхронно** : компонент, отправивший кому-то запрос, ожидает ответа, больше ничего не делая до получения ответа (или разрыва связи по ошибке -- таймауту например).

**4. Параллельность и асинхронизм.**

Множество параллельно работающих компонентов, которые взаимодействуют через асинхронные каналы. Каждый компонент может посылать сообщения другим, однако не обязан пассивно ожидать ответа, и может продолжать свою работу. Асинхронные каналы могут работать по разным схемам (например, обрабатывая сообщения в порядке их поступления, или случайно), и такие каналы называются  **потоки (streams)** .
В этой схеме компонент должен знать некоторый идентификатор компонента, с которым он обменивается сообщениями.

**5. Параллельный почтовый ящик.**

Это разновидность предыдущей схемы, когда асинхронные каналы работают как "почтовые ящики", накапливая поступающие сообщения, каждое из которых адресуется конкретному компоненту. В таком случае появляется возможность выполнять сопоставление с образцом, выделяя нужное подмножество сообщений в канале, и не затрагивая другие сообщения, что очень удобно в параллельных системах. Такая схема реализована, например, в языке Erlang.

**6. Согласованная модель.**

Это схема, когда отправитель и получатель сообщений не должны знать идентификационную информацию друг друга. Такая абстракция называется **пространство кортежей (tuple space)** -- парадигма ассоциативной памяти для параллельных/распределённых вычислений, применяемая к интерфейсам компонентов. Компоненты работают параллельно, и взаимодействуют исключительно через общее пространство кортежей.
Один компонент может асинхронно отправить сообщение, а другой -- "получить" его в том смысле, что его надо явно найти по шаблону, как в почтовом ящике.

### Принцип независимости модели

Каждый компонент в системе может разрабатываться в какой-то своей оригинальной вычислительной модели. В процессе разработки внутренняя структура компонента может кардинально изменяться: нередко меняется вычислительная модель, stateless-компонент может стать компонентом с состоянием (или параллельным, или распределённым, и т.д.), или наоборот.

Если такое изменение происходит на уровне реализации компонента, нет необходимости изменять его интерфейс.  **Интерфейс требуется менять только в том случае, если меняется функциональность компонента, видимая извне** . Это важное свойство модульности вычислительных моделей. До тех пор, пока интерфейс остается неизменным, это свойство гарантирует, что нет необходимости изменять что-либо ещё в остальной части системы.

Это базовый принцип проектирования для всех вычислительных моделей:

**Интерфейс компонента должен быть независим от вычислительной модели, используемой для реализации компонента. Интерфейс зависит исключительно от внешне видимой функциональности компонента** .

Хороший пример этого принципа -- мемоизация. Функция вычисляет некоторый результат, который требует существенного объёма вычислений, и кэширует свои параметры так, что если вызов функции с конкретными значениями уже выполнялся, то сразу выдаётся уже готовый результат, вычисленный ранее. Но несмотря на то, что кэш мемоизации, очевидно, требует работы с состояниями (мы переходим от декларативной модели к stateful-модели), смена внутренней реализации компонента не требует абсолютно никаких изменений в остальном коде системы.


### Взаимодействие между компонентами (задания)

======= 40. Чем протокол с корутинами отличается от протокола с функциями?

[1 ] в случае корутин существует несколько фокусов контроля

[ ] компоненты с корутинами выполняются независимо

[ ] функции могут быть вложены, а корутины нет

======= 41. Чем синхронизм отличается от асинхронизма?

[ ] компоненты и там и там работают параллельно

[ 1] синхронный компонент должен пассивно ожидать ответа связанного компонента

[ ] синхронный компонент должен знать идентификатор связанного компонента

======= 42. В чём разница между моделью почтового ящика и согласованной моделью?

[ ] почтовые ящики работают как синхронные каналы

[ +] в согласованной модели используется ассоциативная память

[ ] отправитель и получатель всегда должны знать идентификационную информацию

======= 43. В чём заключается базовый принцип проектирования?

[ ] интерфейс компонента должен быть согласован с вычислительной моделью его реализации

[1] интерфейс компонента независим от вычислительной модели в его реализации

[ ] интерфейс компонента зависит от внешней и внутренней функциональности компонента
