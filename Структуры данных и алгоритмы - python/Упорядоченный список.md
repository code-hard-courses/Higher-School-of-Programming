## Упорядоченный список

Мы рассмотрели два вида связанных списков: одно- и двухсторонние, когда каждый элемент хранит ссылки либо только на следующий, либо и на следующий, и на предыдущий элементы. Конкретный тип мы можем выбирать в зависимости от задачи. Например, если мы уверены, что данные требуется сканировать только в одном направлении (потоковые структуры, последовательные связанные логи и т. п.), лучше брать односторонний список, как немного более эффективный.

Существует довольно большой класс задач, когда нам очень удобно хранить данные в списке в упорядоченном виде. Во-первых, существенно ускоряется поиск нужного элемента. Во-вторых, данные из "внешнего" хранилища, коим обычно служит такой список, очень здорово сразу брать в отсортированном виде, потому что операция сортировки обычно весьма нагрузочная, особенно если данных хранится много.

Мы воспользуемся общей схемой двустороннего списка, который вы делали во втором задании. Назовём новый тип OrderedList.
Однако теперь нам понадобятся далеко не все методы, которые были в классе LinkedList2. Ведь отныне позиция каждого элемента в списке определяется автоматически, по его значению относительно других элементов.

По сути, нам требуются всего три операции: добавление элемента по его значению, удаление элемента по его значению (остаётся без изменений, как в классе LinkedList2) и нахождение элемента по его значению.

Упорядоченный список на практике часто расширяют возможностью обращения к его элементам по индексу. Подобный доступ работает не так быстро, как в случае массива (не за O(1)), но и не за O(N), а логарифмически, потому что элементы отсортированы, и можно применять, например, двоичный поиск. Основные операции над таким "упорядоченным массивом" становятся логарифмическими (и доступ, и поиск, и добавление/удаление), и для немалого числа задач такой подход вполне оправдан. Например, мы можем за O(1) получить минимальное, максимальное и среднее значения, за O(N) выявить все дубликаты и найти наиболее часто встречающееся значение, организовать эффективное слияние таких списков, что мы изучаем на курсе по сортировкам и поиску, и т. д.

**Задание**

Реализуйте:

1. Дополнительную опцию asc в конструкторе OrderedList, которая указывает, по возрастанию (True) или по убыванию (False) должны храниться элементы в массиве.
   Эту опцию сделайте приватной -- изменять её можно только в конструкторе и методе очистки clean().
2. Метод сравнения двух значений compare(). В общем случае, мы можем хранить в нашем списке произвольные объекты (например, экземпляры класса Cat), и способ, которым мы желаем их сравнивать, потенциально может быть самым произвольным. Пока сделайте базовый вариант этого метода, который сравнивает числовые значения.
3. Добавление нового элемента по значению add() с единственным параметром -- новым добавляемым значением (новый узел для него создавайте внутри метода add). Элемент должен вставиться автоматически между элементами с двумя подходящими значениями (либо в начало или конец списка) с учётом его значения и признака упорядоченности. Используйте для этого метод сравнения значений из предыдущего пункта.
4. Создайте OrderedStringList -- наследник текущего класса, который будет упорядоченно хранить строки. Для этого переопределите в нём метод сравнения значений -- он должен сравнивать строки, очищенные от начальных и конечных пробелов.
5. Переделайте функцию поиска элемента по значению с учётом признака упорядоченности и возможности раннего прерывания поиска, если найден заведомо больший или меньший элемент, нежели искомый. Оцените сложность операции поиска, изменилась ли она?
6. Добавьте тесты для добавления, удаления и поиска элемента по его значению -- каждый случай с учётом признака упорядоченности.

**[предыдущее](https://skillsmart.ru/algo/py-kf32y/cab34c87d2f.html)**

---

## заготовка класса для автоматической проверки

```
class Node:
    def __init__(self, v):
        self.value = v
        self.prev = None
        self.next = None

class OrderedList:
    def __init__(self, asc):
        self.head = None
        self.tail = None
        self.__ascending = asc

    def compare(self, v1, v2):
        return 0
        # -1 если v1 < v2
        # 0 если v1 == v2
        # +1 если v1 > v2

    def add(self, value):
        pass
        # автоматическая вставка value 
        # в нужную позицию

    def find(self, val):
        return None # здесь будет ваш код

    def delete(self, val):
        pass # здесь будет ваш код

    def clean(self, asc):
        self.__ascending = asc
        pass # здесь будет ваш код

    def len(self):
        return 0 # здесь будет ваш код

    def get_all(self):
        r = []
        node = self.head
        while node != None:
            r.append(node)
            node = node.next
        return r

class OrderedStringList(OrderedList):
    def __init__(self, asc):
        super(OrderedStringList, self).__init__(asc)

    def compare(self, v1, v2):
        # переопределённая версия для строк
        return 0
```
