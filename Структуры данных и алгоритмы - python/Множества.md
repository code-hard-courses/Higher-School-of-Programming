## Множества

В прошлый раз мы рассмотрели, как хэш-таблицы расширить до концепции словарей. Однако существует одно полезное применение хэш-таблиц самих по себе -- это так называемые множества.

В Python множества реализованы как тип данных set. Это просто неупорядоченное хранилище данных -- мы даже не можем обратиться к нему для извлечения значения по ключу или индексу. Его ключевая особенность -- каждое значение хранится в нём в единичном экземпляре.

Мы можем определить множество из нескольких значений так:

```
a = {1024, '512', 3.14}
```

Следующая запись хоть и считается корректной, однако в переменной a всё равно окажется лишь три значения:

```
a = {1024, '512', 3.14, 3.14} # {1024, '512', 3.14}
```

Поэтому в частности множества удобно использовать для исключения дублирующих значений.

Главный плюс множества -- это высокая скорость проверки, принадлежит ли элемент множеству, её сложность O(1).

Принципиальный момент -- когда будете создавать свои классы подобной направленности, всегда придерживайтесь принципа, что все они должны работать с одним типом данных. Условно говоря, если вы создаёте класс (тип) String, то подразумеваете, что его методы получают данные строкового типа и возвращают тоже данные строкового типа. То есть мы по сути описываем набор операций над одним типом, которые и возвращают данные тоже этого типа (формально говоря, это такая алгебра с замыканием -- замыкание значений нашего типа относительно заданного набора операций над этим типом). Целое плюс целое будет целое, и целое делённое на целое тоже ожидаем целое.

Смысл в этом подходе большой и глубокий. В данном случае intersection(), union(), difference() замкнуты относительно типа PowerSet. Странно было бы объединить два множества, а получить в результате список, а не множество, однако такая наивная ошибка не редкость. Избежать этого помогает принцип, когда в общем случае мы задаём операции над некоторым типом (классом) Т и ожидаем, что например сложение или вычитание множеств тоже дадут в результате множество (что естественно).

Создайте реализующий множество класс PowerSet. Его в принципе можно выполнить на основе класса HashTable, где достаточно будет не допускать добавление уже существующего в множестве значения (изменить оригинальный метод put()). Однако здесь проявляется стандартная для Python проблема, что такую структуру данных эффективно реализовать трудно на самом Python, который компилируется не в машинный код, а в промежуточный, и фактически интерпретируется, поэтому и работает медленно.
Поэтому для внутреннего хранения множества можно взять даже стандартный список (только не стандартное множество, иначе получится "масло масляное"), и просто добавлять и удалять элементы в нём.
В данном случае задача прежде всего в правильной реализации публичных методов множества, но при этом код должен достаточно быстро работать, за 1-2 секунды, с множествами из 20,000 элементов.

В общем случае, если коллизий немного и разрешаются они быстро, то лучше всего подходит хэш-таблица. Если добавления/удаления редки, то хорошо подойдёт упорядоченный список или двоичное дерево.
Вы можете в данном учебном занятии использовать даже стандартный словарь или список (только не стандартное множество set, конечно :), главное чтобы корректно работал публичный интерфейс класса.

Реализуйте следующие типичные для множества методы:

- remove(значение) -- удаление элемента из множества;
- intersection(), в качестве параметра выступает другое множество, а возвращается пересечение этих множеств (множество, в котором есть только те элементы, которые имеются в каждом из множеств);
- union(), в качестве параметра выступает другое множество, а возвращается объединение этих множеств (множество, в котором есть все элементы из каждого множества);
- difference(), в качестве параметра выступает другое множество, а возвращается подмножество текущего множества из таких элементов, которые не входят в множество-параметр;
- issubset(), в качестве параметра выступает другое множество, и проверяется, входят ли все его элементы в текущее множество (будет ли множество-параметр подмножеством текущего множества).

3. Добавьте тесты, которые проверяют:

- возможность добавления отсутствующего элемента и невозможность добавления присутствующего в множестве элемента с помощью put();
- удаление элемента с помощью remove();
- пересечение множеств intersection(), чтобы в результате получались как пустое, так и непустое множества;
- объединение union(), когда оба параметра непустые, и когда один из параметров -- пустое множество;
- разница difference(), чтобы в результате получались как пустое, так и непустое множества;
- подмножество issubset() -- рассмотрите три случая (все элементы параметра входят в текущее множество, все элементы текущего множества входят в параметр, не все элементы параметра входят в текущее множество);
  -- быстродействие (операции над множествами из десятков тысяч элементов укладываются в пару секунд).

**[предыдущее](https://skillsmart.ru/algo/py-kf32y/oca3a927b6.html)**

---

## заготовка класса для автоматической проверки

[Как правильно подготовить ваш код для автоматической проверки](https://skillsmart.ru/algo/py-kf32y/github_py.html)

```
# наследуйте этот класс от HashTable
# или расширьте его методами из HashTable
class PowerSet:

    def __init__(self):
        # ваша реализация хранилища

    def size(self):
        return 0
        # количество элементов в множестве

    def put(self, value):
        # всегда срабатывает

    def get(self, value):
        # возвращает True если value имеется в множестве,
        # иначе False
        return False

    def remove(self, value):
        # возвращает True если value удалено
        # иначе False
        return False

    def intersection(self, set2):
        # пересечение текущего множества и set2
        return None 

    def union(self, set2):
        # объединение текущего множества и set2
        return None

    def difference(self, set2):
        # разница текущего множества и set2
        return None

    def issubset(self, set2):
        # возвращает True, если set2 есть
        # подмножество текущего множества,
        # иначе False
        return False
```
