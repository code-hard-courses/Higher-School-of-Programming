/**
 *
Приведите словесные примеры применения абстрагирования и факторизации.

1. Выделяем товар как более общую сущность для мебели (абстрагирование).
Например, заведение изначально было выставочным мебельным центром, однако затем перепрофилировалось в мебельный магазин, и у каждого экспоната появилась цена. Возможно, попимо мебели в будущем будут продаваться и другие товары.

Между игрушкой и книгой общего нету ничего. Однако для распознавания уникальных экземпляров каждому объекту надо иметь свой идентификатор. Поэтому вводится класс некой базовой абстрактной сущности, имеющей одно поле уникальной идентификации (как, например, мы делали с классами General/Any).
Это пример факторизации (Entity - Book and Toy).

2. Абстрагирование: имеется магазин, торгующий ноутбуками. В ИТ-системе они учитываются в виде одного класса Ноутбук. Но когда магазин расширился, добавились новые виды техники, очевидным решением стало создание родительского класса Товар для класса Ноутбук.

Факторизация: имеются классы Bitcoin, USD, USDT, RUB. USDT и Bitcoin -- это криптовалюта, а USD и RUB -- это обычная валюта, и обе эти группы подразумевают как разные виды операций, так и общие. Но в обощем случае это вс некая валюта, поэтому вполне можно все эти классы унаследовать от одного.

3. Абстрагирование. Практический пример. Разработка воркера:

    1. слушает очередь,
    2. получает ИД задачи,
    3. забирает ее из БД,
    4. выполняет работу на основе полученных из БД параметров,
    5. шлет уведомление пользователю.
Загвоздка была в п.5: при формировании канала, в который нужно послать уведомление, участвовали параметры задачи. А если воркер не имеет параметров, или как-то зависит от результата ответа, или канал динамический, и т. д.? Постепенно пришло понимание, что для разных узкоспециализированных воркеров нужен свой процесс уведомлений.
Так получился абстрактный воркер, "умеющий" все и ничего. Наследник мог включать процессор уведомлений, реализовывал п.4, и т. д.
Факторизация. Для сервиса с меняющимся числом запущенных копий и очередями делались интеграциоонные тесты, которые выходили довольно большими. Ориентироваться в них было тяжело, поэтому общие части тестов были вынесены в общий предок. В итоге организовался класс-предок на 500 строк кода, и около 10 тестов-наследников еще на 100-200 строк каждый. А раньше каждый тест занимал под тысячу строк.

4. Абстрагирование. Начали с небольшой постапокалиптической игры, предположив, что в мире будет только один автомобиль (как в Fallout2). Но в какой-то момент.. мы уже делаем киллер GTA. Теперь нам нужны грузовики, мотоциклы, огромные повозки и т.д. Приходится выводить новую абстракцию и строить иерархию этих объектов.

Факторизация. Предположим мы начали делать РПГ и написали класс Герой, от которого наследовали класс Герой-Маг. Потом добавили монстров -- класс Гоблин и наследника Гоблин-Маг. Вооружили героя оружием "магический меч". Тут стало понятно, что способности к магии реализованы для героя и монстра примерно одинаково.
Решение -- выделить "магические свойства" в отдельный класс, и использовать его как атрибут в классах Герой и Гоблин (а лучше в родительском классе Монстр).